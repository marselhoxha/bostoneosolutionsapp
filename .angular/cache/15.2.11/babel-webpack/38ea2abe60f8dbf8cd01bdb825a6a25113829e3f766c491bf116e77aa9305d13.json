{"ast":null,"code":"import { HttpErrorResponse } from '@angular/common/http';\nimport { BehaviorSubject, throwError } from 'rxjs';\nimport { Key } from '../enum/key.enum';\nimport { catchError, switchMap } from 'rxjs/operators';\nimport * as i0 from \"@angular/core\";\nimport * as i1 from \"../service/user.service\";\nexport class TokenInterceptor {\n  constructor(userService) {\n    this.userService = userService;\n    this.isTokenRefreshing = false;\n    this.refreshTokenSubject = new BehaviorSubject(null);\n  }\n  intercept(request, next) {\n    if (request.url.includes('verify') || request.url.includes('login') || request.url.includes('register') || request.url.includes('refresh') || request.url.includes('resetpassword')) {\n      return next.handle(request);\n    }\n    return next.handle(this.addAuthorizationTokenHeader(request, localStorage.getItem(Key.TOKEN))).pipe(catchError(error => {\n      if (error instanceof HttpErrorResponse && error.status === 401 && error.error.reason.includes('expired')) {\n        return this.handleRefreshToken(request, next);\n      } else {\n        return throwError(error);\n      }\n    }));\n  }\n  handleRefreshToken(request, next) {\n    if (!this.isTokenRefreshing) {\n      console.log('Refreshing Token...');\n      this.isTokenRefreshing = true;\n      this.refreshTokenSubject.next(null);\n      return this.userService.refreshToken$().pipe(switchMap(response => {\n        console.log('Token Refresh Response:', response);\n        this.isTokenRefreshing = false;\n        this.refreshTokenSubject.next(response);\n        console.log('New Token:', response.data.access_token);\n        console.log('Sending original request:', request);\n        return next.handle(this.addAuthorizationTokenHeader(request, response.data.access_token));\n      }));\n    } else {\n      this.refreshTokenSubject.pipe(switchMap(response => {\n        return next.handle(this.addAuthorizationTokenHeader(request, response.data.access_token));\n      }));\n    }\n  }\n  addAuthorizationTokenHeader(request, token) {\n    return request.clone({\n      setHeaders: {\n        Authorization: `Bearer ${token}`\n      }\n    });\n  }\n}\nTokenInterceptor.ɵfac = function TokenInterceptor_Factory(t) {\n  return new (t || TokenInterceptor)(i0.ɵɵinject(i1.UserService));\n};\nTokenInterceptor.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n  token: TokenInterceptor,\n  factory: TokenInterceptor.ɵfac\n});","map":{"version":3,"mappings":"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","names":["HttpErrorResponse","BehaviorSubject","throwError","Key","catchError","switchMap","TokenInterceptor","constructor","userService","intercept","request","next","url","includes","handle","addAuthorizationTokenHeader","localStorage","getItem","TOKEN","pipe","error","status","reason","handleRefreshToken","isTokenRefreshing","console","log","refreshTokenSubject","refreshToken$","response","data","access_token","token","clone","setHeaders","Authorization","factory"],"sourceRoot":"","sources":["/Users/marsel/bostoneo/bostoneosolutionsapp/src/app/interceptor/token.interceptor.ts"],"sourcesContent":["import { Injectable } from '@angular/core';\nimport {\n  HttpRequest,\n  HttpHandler,\n  HttpEvent,\n  HttpInterceptor,\n  HttpResponse,\n  HttpErrorResponse\n} from '@angular/common/http';\nimport { BehaviorSubject, Observable, Subject, throwError } from 'rxjs';\nimport { Key } from '../enum/key.enum';\nimport { catchError, switchMap } from 'rxjs/operators';\nimport { UserService } from '../service/user.service';\nimport { CustomHttpResponse, Profile } from '../interface/appstates';\n\n@Injectable()\nexport class TokenInterceptor implements HttpInterceptor {\n  private isTokenRefreshing: boolean = false;\n  private refreshTokenSubject: BehaviorSubject<CustomHttpResponse<Profile>> = new BehaviorSubject(null);\n\n  constructor(private userService: UserService) {}\n\n  intercept(request: HttpRequest<unknown>, next: HttpHandler): Observable<HttpEvent<unknown>> | Observable<HttpResponse<unknown>>{\n    if(request.url.includes('verify') || request.url.includes('login') || request.url.includes('register') \n            || request.url.includes('refresh') || request.url.includes('resetpassword')) {\n          return next.handle(request);\n      }\n    return next.handle(this.addAuthorizationTokenHeader(request, localStorage.getItem(Key.TOKEN)))\n      .pipe(\n        catchError((error: HttpErrorResponse) => {\n          if(error instanceof HttpErrorResponse && error.status === 401 && error.error.reason.includes('expired')) {\n            return this.handleRefreshToken(request, next);\n          } else {\n            return throwError(error);\n          }\n        })\n      );\n  }\n\n  private handleRefreshToken(request: HttpRequest<unknown>, next: HttpHandler): Observable<HttpEvent<unknown>> {\n    if(!this.isTokenRefreshing) {\n      console.log('Refreshing Token...');\n      this.isTokenRefreshing = true;\n      this.refreshTokenSubject.next(null);\n      return this.userService.refreshToken$().pipe(\n        switchMap((response) => {\n          console.log('Token Refresh Response:', response);\n          this.isTokenRefreshing = false;\n          this.refreshTokenSubject.next(response);\n          console.log('New Token:', response.data.access_token);\n          console.log('Sending original request:', request);\n          return next.handle(this.addAuthorizationTokenHeader(request, response.data.access_token))\n        })\n      );\n    } else {\n      this.refreshTokenSubject.pipe(\n        switchMap((response) => {\n          return next.handle(this.addAuthorizationTokenHeader(request, response.data.access_token))\n        })\n        )\n    }\n  }\n\n  private addAuthorizationTokenHeader(request: HttpRequest<unknown>, token: string): HttpRequest<any> {\n    return request.clone({ setHeaders: { Authorization: `Bearer ${token}` }});\n  }\n}\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}